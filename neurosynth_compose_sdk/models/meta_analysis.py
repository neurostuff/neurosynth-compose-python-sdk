# coding: utf-8

"""
    Analysis Specification for Meta-analysis

    api to create a meta-analysis specification  # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: jamesdkent21@gmail.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Any, Dict, List, Optional
from pydantic import BaseModel, Field, StrictStr, conlist
from neurosynth_compose_sdk.models.meta_analysis_annotation import MetaAnalysisAnnotation
from neurosynth_compose_sdk.models.meta_analysis_results_inner import MetaAnalysisResultsInner
from neurosynth_compose_sdk.models.meta_analysis_specification import MetaAnalysisSpecification
from neurosynth_compose_sdk.models.meta_analysis_studyset import MetaAnalysisStudyset

class MetaAnalysis(BaseModel):
    """
    The combination of the specification determining what meta-analysis to run (required), the studyset to act as input to the meta-analytic algorithm (required), and the annotation to provide human readable annotations as well as acts as an optional filter on which analyses to select within the studyset (optional, but suggested).
    """
    specification: Optional[MetaAnalysisSpecification] = None
    studyset: Optional[MetaAnalysisStudyset] = None
    annotation: Optional[MetaAnalysisAnnotation] = None
    name: Optional[StrictStr] = Field(None, description="Human-readable name of the meta-analysis.")
    description: Optional[StrictStr] = Field(None, description="Long form description of the meta-analysis.")
    internal_studyset_id: Optional[StrictStr] = Field(None, description="The id of the studyset on neurosynth-compose (as opposed to the id of the studyset on neurostore). Multiple snapshots of the studyset can be stored on neurosynth-compose so knowing which snapshot is being referenced is necessary.")
    internal_annotation_id: Optional[StrictStr] = Field(None, description="The id of the annotation on neurosynth-compose (as opposed to the id of the annotation on neurostore). Multiple snapshots of the annotation can be stored on neurosynth-compose so knowing which snapshot is being referenced is necessary.")
    results: Optional[conlist(MetaAnalysisResultsInner)] = Field(None, description="array of neurostore ids representing the results of this meta-analysis (nominally all results should be the same, but machine architecture differences/algorithm stochastic-ness may lead to slightly different outcomes for each result.")
    provenance: Optional[Dict[str, Any]] = None
    project: Optional[StrictStr] = None
    __properties = ["specification", "studyset", "annotation", "name", "description", "internal_studyset_id", "internal_annotation_id", "results", "provenance", "project"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> MetaAnalysis:
        """Create an instance of MetaAnalysis from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of specification
        if self.specification:
            _dict['specification'] = self.specification.to_dict()
        # override the default output from pydantic by calling `to_dict()` of studyset
        if self.studyset:
            _dict['studyset'] = self.studyset.to_dict()
        # override the default output from pydantic by calling `to_dict()` of annotation
        if self.annotation:
            _dict['annotation'] = self.annotation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in results (list)
        _items = []
        if self.results:
            for _item in self.results:
                if _item:
                    _items.append(_item.to_dict())
            _dict['results'] = _items
        # set to None if name (nullable) is None
        # and __fields_set__ contains the field
        if self.name is None and "name" in self.__fields_set__:
            _dict['name'] = None

        # set to None if description (nullable) is None
        # and __fields_set__ contains the field
        if self.description is None and "description" in self.__fields_set__:
            _dict['description'] = None

        # set to None if provenance (nullable) is None
        # and __fields_set__ contains the field
        if self.provenance is None and "provenance" in self.__fields_set__:
            _dict['provenance'] = None

        # set to None if project (nullable) is None
        # and __fields_set__ contains the field
        if self.project is None and "project" in self.__fields_set__:
            _dict['project'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> MetaAnalysis:
        """Create an instance of MetaAnalysis from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return MetaAnalysis.parse_obj(obj)

        _obj = MetaAnalysis.parse_obj({
            "specification": MetaAnalysisSpecification.from_dict(obj.get("specification")) if obj.get("specification") is not None else None,
            "studyset": MetaAnalysisStudyset.from_dict(obj.get("studyset")) if obj.get("studyset") is not None else None,
            "annotation": MetaAnalysisAnnotation.from_dict(obj.get("annotation")) if obj.get("annotation") is not None else None,
            "name": obj.get("name"),
            "description": obj.get("description"),
            "internal_studyset_id": obj.get("internal_studyset_id"),
            "internal_annotation_id": obj.get("internal_annotation_id"),
            "results": [MetaAnalysisResultsInner.from_dict(_item) for _item in obj.get("results")] if obj.get("results") is not None else None,
            "provenance": obj.get("provenance"),
            "project": obj.get("project")
        })
        return _obj

